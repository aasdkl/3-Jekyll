#include <stdio.h>
#include <stdlib.h>

/*
 * 合理的使用字符可以实现最基本的绘图效果
 *━━┳━┳━━━┳━━━━━━━┳━┳━┓
 *  ┃ ┃   ┃       ┃ ┃ ┃
 *┃ ┃ ┃ ┏━┛ ┃ ┏━━━┛ ┃ ┃
 *┃ ┃   ┃   ┃ ┃       ┃
 *┃ ┃ ┃ ┃ ┃ ┃ ┃ ━━━━┓ ┃
 *┃   ┃   ┃ ┃       ┃ ┃
 *┃ ━━┻━┳━┻━┻━━ ┏━━ ┃ ┃
 *┃     ┃       ┃   ┃ ┃
 *┃ ┃ ┃ ┃ ┏━━━━ ┃ ┃ ┣━┫
 *┃ ┃ ┃ ┃ ┃     ┃ ┃ ┃ ┃
 *┃ ┣━┛ ┣━┫ ━━┓ ┃ ┗━┛ ┃
 *┃ ┃   ┃ ┃   ┃ ┃     ┃
 *┃ ┃ ━━┫ ┣━━ ┣━┫ ┏━━━┫
 *┃ ┃   ┃ ┃   ┃ ┃ ┃   ┃
 *┣━┛ ━━┫ ┗━━━┛ ┃ ┃ ━━┫
 *┃     ┃         ┃   ┃
 *┃ ━━┳━┫ ┏━━━━ ┏━┛ ┃ ┃
 *┃   ┃ ┃ ┃     ┃   ┃ ┃
 *┣━━━┛ ┗━┛ ┃ ━━┛ ┏━┛ ┃
 *┃         ┃     ┃    
 *┗━━━━━━━━━┻━━━━━┻━━━━
 */

int main()
{
/*
 * 现在假设我们想要实现一个贪吃蛇，首先我们应该有一个矩形场地
 */
	char bg[20][20];
/*
 * 我们用字符'.'代表空地，'#'代表蛇的一部分
 * 你说食物？那个我们暂时不关心……
 */
	int i, j;
	for (i = 0; i < 20; ++i)
		for (j = 0; j < 20; ++j)
			bg[i][j] = '.';
/*
 * 蛇先放在3,2
 * 这时的蛇只有一个点
 */
	bg[3][2] = '#';

/*
 * 我们需要实现蛇的移动，必须了解蛇的位置
 * 一个简单的方法是开数组记录蛇的每个位置
 * int R[n], C[n];
 * 用R表示第一个坐标，C表示第二个。这有两点不太好，一是没有表示出R和C的关联性
 * 二是我们不知道蛇有多长意味着我们要保证数组足够大，但是20×20的蛇长对一般玩家不可想象，
 * 这是一种浪费
 */
	struct body {
		int r, c;
		struct body* next;
	};
/*
 * 我们不一定要时刻关注整条蛇的坐标，整条蛇是按顺序连接在一起的，设想我们知道蛇头的位置，
 * 知道蛇的每一个部分下一个点是什么，我们就可以从蛇头开始逐个向后查看整条蛇。
 */
//	struct body head;
//	head.r = 3; head.c = 2;
//	head.next = NULL;

/*
 * 现在我们来考虑蛇的移动，表面上看蛇移动后我们要改变整个蛇的坐标，事实上
 *  ..#.     ....
 *  ..#. ->  ..#.
 *  ..#.     .##.
 * 我们可以认为蛇尾消失了，前面多了一个新的头
 * 但我们的head变量是声明时就确定的，不能变成一个新的变量
 */
	struct body *phead;
	phead = (struct body *)malloc(sizeof(struct body));
	phead->r = 3;
	phead->c = 2;
	phead->next = NULL;

/*
 * 加入一个新的头部
 */
	struct newhd;
/*
 * 假定我们在实现一个左移, 新头部和原头部的坐标只差一个位置，它的下一个点是原头部
 */
	newhd.r = phead->r;
	newhd.c = phead->c - 1;
	newhd.next = phead;
/*
 *  更新指向头部的指针
 */
	phead = &newhd;

/*
 * 怎么找蛇尾？ 蛇尾事实上就是一个找不到下一个点的蛇身节点
 */	
	struct body *check = phead;
	while (check->next != NULL) {
		check = check->next;
	}
/*
 * 循环结束时，check应当指向蛇尾，为何使用指针呢？这是为了可以删除蛇尾
 */

//	free(check);

/*
 * 这是个错误！，check只是一个指针，新的蛇尾没有改变，它仍然认为自己的下一个点是存在的
 */

	struct body *last = NULL;
	check = phead;
	while (check->next != NULL) {
		last = check; check = check->next;
	}

	free(check);
//	if (last != NULL)
		last->next = NULL;
//	else
//		phead = NULL;

/*
 * last = (nil)意味着蛇的长度是一，应该删除蛇头,但是我们已经加入了一个新头部，所以
 * last = NULL是不会发生的
 */
}
