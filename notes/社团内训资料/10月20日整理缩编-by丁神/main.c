/*
 * 计算机内数据存储的特点： 有序
 * 		每个寄存器都有确定的物理位置，无论物理位置与逻辑顺序的关系如何，序是天然存在的。
 * C作为比较贴近系统底层的语言，其中的数据存储也有这样的特点
 *		
 * 	变量：
 * 		Name -> (Add:Val)
 *  	每个变量名背后是一个变量地址与变量数值组成的二元组，一般来说地址由系统分配。
 *  	但实际使用一个变量往往只需要其中的一个值。
 *		一般来说，赋值（=）一类符号左边出现的变量会取地址,右边出现的会取值
 *		所以对int A可以写A=A+1而不可写A+1=A（A+1的地址有没有被分配不是我们决定的）
 * 		这种表示可以让我们直接关注我们希望的数值，掩盖了复杂的内存管理
 *
 *  数组：
 *  	当我们需要连续的一串变量时，如果写A1,A2,A3,……，An将大大提高管理的难度。
 * 		C提供了一种机制int A[n]。(理解程序语言的语法很多时候可以使用模式匹配的思想，譬如
 * 		数组的声明方法为在变量声明的变量名位置加上了[]，那么int A[n][n]则是把A[n]视为变
 * 		变量声明以A[n]为单位的数组）数组代表一段在存储空间中连续的相同变量，变量名的地址
 * 		其实是这一段变量开始的地址。
 *      A0    1    2    3   
 * 		[    |    |    |    ]  
 * 		使用连续变量中的某一个时，调用的方法为A[i]（例如A[2] = A[0]+1;左边是A地址向后2
 *      位的变量，右边是A位置（向后0位）的变量，仍然是左边取名字对应的地址，右边取值）
 * 		注意使用A[i]和声明A[n]的区别。单纯取地址则可以使用A(+0)，A+1, A+2
 * 		见Array.c
 * 		
 *	指针：
 * 		对于比较贴近底层的C，使用者仍然有一定的管理内存权限，指针的声明方式是在一般的变量
 * 		声明的变量名前面加*,例如int *B(同理，将*B视为一个变量类型，可以写出int **B, 或
 *      int ****B)。既然变量的两部分同样是用二进制数字来表示的，就可以把val部分同样当成
 * 		一个地址来解读。
 * 		对于一个变量，C提供了不按照默认方法来选择取地址还是取值的手段 *A/&A
 *		         （*A)=======>
 *		A[NUM0:NUM1] -  B[NUM1:NUM2]
 *		       (&B）
 *		*意味着向“右”查找一次，即将当前变量的值当成一个地址位查找对应的变量，所以A的值是
 *      NUM1,*A的值NUM2 (注意A为int *)。而&则是向“左”，所以&B为NUM1（注意&B是一个值）
 *		
 *		数组也可以被当成指针使用，例如*A和A[0]相同，*(A+1)和A[1]相同。（A+1和A的差，取
 *		居于A的单位元素有多大，比如int大小是4字节）
 *		因而也可以声明数组指针 int *A[10]，这会声明连续10个指针，每个指针是一个int *
 *		因为变量在声明后才会得到空间，因而直接使用*A会出现问题，需要用malloc申请空间
 *      见Pointer.c
 *
 * 结构体:
 *  	结构体是基本数据类型联合在一起的，使用者定义的数据类型。譬如我们需要一个复数类型时
 *      可以声明 struct complex{int R; int I;};    模式为
 * 		struct NAME{BASIC_DATA1; BD2; BD3; ... };
 *		使用时可写 C.R = 1; C.I = 3; 采用变量名+'.'+结构体内部基本变量名;
 * 		如声明了complex *类型的指针变量D，可以使用C->R = 2, C->I = 5;的专门用法，不必
 * 		按一般情况先加*再处理。
 *		见Struct.c 
 *
 * 实际使用：
 * 		见Draft.c
 */

#include <stdio.h>

int main()
{
	puts("仅供参考");
	puts("正式的深入学习还请多看书");

	return 0;
}
